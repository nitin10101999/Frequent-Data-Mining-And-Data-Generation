# -*- coding: utf-8 -*-
"""FPTree

Automatically generated by Colaboratory.

Original file is located at
		https://colab.research.google.com/drive/1NfbqrGSuPIMf5vMSb5IoJKFlyk4-WiDI
"""

#import os
#os.chdir('/content/drive/My Drive/Code')

import numpy as np
import pandas as pd
import copy 
import math
import csv
import time
import sys
import os
import psutil

# Default value
MIN_SUPPORT_COUNT = 1
FRACTION = 0.005
NO_OF_TRANSACTION = 100
MAX_FREQ_ITEMSET_SIZE = 5
NO_OF_FREQ_ITEM = 1
TRANSACTION_AVG_WIDTH = 4
TOTAL_ITEMS = 10
EXECUTION_TIME = 0

class Node:
	def __init__(self, name):
		self.name = name
		self.count = 1
		self.children = set()
		self.nextPointer = None
		self.parent =	None
	def incrementCount(self):
		self.count = self.count + 1
	def incrementCountOffset(self,offset):
		self.count = self.count + offset
	def addChild(self,node):
		self.children.add(node)
		node.parent = self
	def removeChild(self,node):
		newSet = set()
		for child in self.children:
			if child != node:
				newSet.add(child)	
		self.children = newSet
		#self.children.remove(node)
	def getChildren(self):
		return self.children
	def getCount(self):
		return self.count
	def getName(self):
		return self.name
	def setNextPointer(self,nextNode):
		self.nextPointer = nextNode
	def getNextPointer(self):
		return self.nextPointer
	def getParent(self):
		return self.parent
class CondPatNode:
	def __init__(self,condPat,count):
		self.condPat = condPat
		self.count = count
	def getcondPat(self):
		return self.condPat
	def getCount(self):
		return self.count

def insertItems(itemList,root,df):
	for item in itemList:
		children = root.getChildren()
		foundChild = False
		for node in children:
			if node.getName() == item:
				node.incrementCount()
				root = node
				foundChild = True
				break
		if not foundChild:
			newnode = Node(item)
			df_row = df.index[df['item'] == item].tolist()
			df_row = df_row[0]
			if not df.at[df_row ,'pointer'] is None:
				newnode.setNextPointer(df.at[df_row,'pointer'])
			df.at[df_row,'pointer'] = newnode
			root.addChild(newnode)
			root = copy.copy(newnode)

def FPTreeUtil(df,data,root):
	print('Inside	FPTree Util')
	for transaction in data:
		mp = {}
		for item in df['item']:
			mp[item] = 0
		#Find Item in transaction in the count order
		for item in transaction:
			try:
				mp[item] = mp[item] + 1
			except:
				dummy = 0
		itemTobeAdd = []
		for item in df['item']:
			if mp[item] != 0:
				itemTobeAdd.append(item)
		newRoot = copy.copy(root)
		insertItems(itemTobeAdd,newRoot,df)

def printTree(root,level):
	print(root.getName(),':',root.getCount(),':',level)
	for child in root.getChildren():
		printTree(child,level+1)
	
def printNeighour(df):
	nodes = df['pointer']
	for node in nodes:
		while not node is None:
			print(node.getName(),':',node.getCount(),'->',end=" ")
			node = node.getNextPointer()
		print('')

def findPrefixPath(node,prefixPath):
	if not node.getParent() is None:
		prefixPath.append(node.getName())
		findPrefixPath(node.getParent(),prefixPath)
	
def conditionalPatternBase(node):
	conditionalPats = []
	while not node is None:
		prefixPath = []
		findPrefixPath(node,prefixPath)
		if len(prefixPath) > 1:
			condNode = CondPatNode(prefixPath[1:],node.getCount())
			conditionalPats.append(condNode)
		node = node.getNextPointer()
	return conditionalPats
	
def createCondFPTreeUtil(root,itemList,count,NextPointer):
	index = len(itemList) - 1
	while index >= 0:
		children = root.getChildren()
		#print(len(children))
		foundChild = False
		for node in children:
			if node.getName() == itemList[index]:
				node.incrementCountOffset(count) # have to modify
				root = node
				foundChild = True
				break
		if not foundChild: 
			newnode = Node(itemList[index])
			newnode.incrementCountOffset(count-1) # 1 has been increased by default
			if not NextPointer[itemList[index]] is None:
				newnode.setNextPointer(NextPointer[itemList[index]])
			NextPointer[itemList[index]] = newnode
			root.addChild(newnode)
			root = newnode
		index = index -1
	
def UpdateCondFPTree(root,dic,NextPointer):
	for item in dic:
		if dic[item] < MIN_SUPPORT_COUNT:
		# Delete Such Node
			node = NextPointer[item]
			while not node is None:
				parent = node.getParent()
				for child in node.getChildren():
					parent.addChild(child)
				parent.removeChild(node)
				node = node.getNextPointer()

def FindAllPathToleaf(root,path,paths):
	if root is None:
		return
	if root.getName() != 'null':
		path[root.getName()] = root.getCount()
		#path.append(root.getName())
	if len(root.getChildren()) == 0:
		paths.append(path.copy())
	for child in root.getChildren():
		FindAllPathToleaf(child,path,paths)
	if root.getName() != 'null':
		del path[root.getName()]


def findAllSubSet(itemSet,freqItem,index,minCount,freqItemSet):
	if index == len(itemSet):
		if len(freqItem) != 0:
			try:
				count = freqItemSet[tuple(freqItem)]
				freqItemSet[tuple(freqItem)] = count + minCount
			except:
				freqItemSet[tuple(freqItem)] =	minCount
			#print(fre,'::',minCount)
		return
	
	item = list(itemSet)[index]
	freqItem.append(item)
	prevminCount = minCount
	if itemSet[item] < minCount:
		minCount = itemSet[item]
	findAllSubSet(itemSet,freqItem,index+1,minCount,freqItemSet)
	freqItem.remove(item)
	findAllSubSet(itemSet,freqItem,index+1,prevminCount,freqItemSet)

def createCondFPTree(condPats,additional,AllfrequentItem):
	root = Node('null')
	dic = {}
	NextPointer = {}
	for pat in condPats:
		for item in pat.getcondPat():
			try:
				dic[item] += pat.getCount()
			except:
				dic[item] = pat.getCount()
				NextPointer[item] = None
	for pat in condPats:
		createCondFPTreeUtil(root,pat.getcondPat(),pat.getCount(),NextPointer)
	UpdateCondFPTree(root,dic,NextPointer)
	#print(dic)
	L1= []
	L1_Count = []
	L1_NodePointer = []
	for item in dic:
		if dic[item] >= MIN_SUPPORT_COUNT:
			lst = [item]
			if lst == list(additional):
				print(lst)
			else:
				lst.extend(list(additional))
			#print(lst,':',list(additional))
			AllfrequentItem[tuple(lst)] = dic[item]
			L1.append(tuple(lst))
			L1_Count.append(dic[item])
			L1_NodePointer.append(NextPointer[item])
	df = pd.DataFrame({
		'item': L1,
		'count': L1_Count,
		'pointer': L1_NodePointer
	})
	df = df.sort_values(by='count', ascending=False)
	return df

def hasSinglePath(itemList):
	singlePath = True
	# go to parent
	node = itemList[0]
	while node.getName() != 'null':
		node = node.getParent()
	while not node is None:
		children = node.getChildren()
		if len(children) > 1:
			return False
		if len(children) == 1:
			for child in children:
				node = child
		else:
			break 
	return singlePath

def FPGrowth(df,AllfrequentItem):
	itemList = df['pointer']
	index = len(itemList) - 1
	if hasSinglePath(itemList):
		path = {}
		freqItem = []
		freqItemSet = {}
		minCount = 100000
		listToAdd = '1'
		for item in itemList:
			path[item.getName()] = item.getCount()
		
		itemsName = df['item'][0]
		listToAdd = list(itemsName)
		listToAdd = listToAdd[1:]

		findAllSubSet(path,freqItem,0,minCount,freqItemSet)
		for item in freqItemSet:
			newList = list(item)
			newList.extend(listToAdd)
			AllfrequentItem[tuple(newList)] = freqItemSet[item]
	
	else:
		while index >= 0:
			condPats = conditionalPatternBase(itemList[index])
			if not type(df['item'][index]) is tuple:
				conv = [df['item'][index]]
				conv = tuple(conv)
				AllfrequentItem[conv] = df['count'][index]
			else:
				conv = df['item'][index]
			newdf = createCondFPTree(condPats,conv,AllfrequentItem)
			if not newdf.empty:
				FPGrowth(newdf,AllfrequentItem)
			#print('------------------------------------------------>>>>>>>>')
			index = index -1
	

def find_frequent_ItemCount(data,uniqueItems):
	L1 = []
	L1_Count = []
	L1_NodePointer = []
	for item in uniqueItems:
		countItem = 0
		for transaction in data:
			for transItem in transaction:
				if transItem == item:
					countItem = countItem + 1
					break
		
		#If count>=MinSupportCount 
		if countItem >= MIN_SUPPORT_COUNT:
			L1.append(item)
			L1_Count.append(countItem)
			L1_NodePointer.append(None)
	
	df = pd.DataFrame({
		'item': L1,
		'count': L1_Count,
		'pointer': L1_NodePointer
	})
	#print(df)
	df = df.sort_values(by='count', ascending=False)
	#print(df)
	return df

def FPTree(data,uniqueItems):
	print('Inside FPTree Initialize')
	df = find_frequent_ItemCount(data,uniqueItems)
	root = Node('null')
	AllfrequentItem = {}
	if not df.empty:
		FPTreeUtil(df,data,root)
		FPGrowth(df,AllfrequentItem)
	MaxLength = 0
	for item in AllfrequentItem:
		if len(item) > MaxLength:
				MaxLength = len(item)
	MaxLenFreqItemSet = []
	for item in AllfrequentItem:
		if len(item) == MaxLength:
			MaxLenFreqItemSet.append(item)
		
	for itemSet in MaxLenFreqItemSet:
		print(itemSet)
	global MAX_FREQ_ITEMSET_SIZE
	global NO_OF_FREQ_ITEM
	MAX_FREQ_ITEMSET_SIZE = MaxLength
	NO_OF_FREQ_ITEM = len(MaxLenFreqItemSet)

def fetchtxtData(data,filename):
	# Using readlines() 
	file_read = open(filename, 'r') 
	Lines = file_read.readlines() 

	count = 0
	# Strips the newline character 
	TotalItems = 0
	UniqueItems = set()
	
	for line in Lines: 
		arr = line.split(" ")
		arr = arr[:len(arr)-1]
		UniqueItems = UniqueItems.union(set(arr))
		TotalItems = TotalItems + len(arr)
		data.append(arr)
		count = count + 1
	#set data
	global NO_OF_TRANSACTION
	global TRANSACTION_AVG_WIDTH
	global TOTAL_ITEMS

	NO_OF_TRANSACTION = count
	TRANSACTION_AVG_WIDTH = TotalItems/NO_OF_TRANSACTION
	TOTAL_ITEMS = len(UniqueItems)
	return list(UniqueItems)	

def fetchCSVdata(data,filename):
	reader = csv.reader(open(filename, 'r'), delimiter=',')
	DataSet = [list(row[1:]) for row in reader]
	DataSet = DataSet[1:]
	
	count = 0
	TotalItems = 0
	uniqueItems = set()
	for trans in DataSet:
		newlist = []
		for elem in trans:
			if elem == '':
				break
			newlist.append(elem)
		uniqueItems = uniqueItems.union(set(newlist))
		data.append(newlist)
		count += 1
		TotalItems += len(newlist)
	# set data
	global NO_OF_TRANSACTION
	global TRANSACTION_AVG_WIDTH
	global TOTAL_ITEMS
	NO_OF_TRANSACTION = count
	TRANSACTION_AVG_WIDTH = TotalItems/NO_OF_TRANSACTION
	TOTAL_ITEMS = len(uniqueItems)
	return list(uniqueItems)

def printData():
	print('----------------------------------------------------')
	print('Minimum support Count:',MIN_SUPPORT_COUNT)
	print('No of Transaction:',NO_OF_TRANSACTION)
	print('Avg Width of Transaction:',TRANSACTION_AVG_WIDTH)
	print('Total Items:',TOTAL_ITEMS)
	print('Max Freq Item Size:',MAX_FREQ_ITEMSET_SIZE)
	print('No of Freq Items:',NO_OF_FREQ_ITEM)
	print('Execution Time:',EXECUTION_TIME)
	print('Memory Used in Bytes',MEMORY)

def main():
	args = sys.argv 
	fileName = ''
	global FRACTION
	isCSV = True
	try:
		 fileName = args[1]
		 if fileName[-3:] == 'txt':
		 	isCSV = False
		 FRACTION = float(args[2])
	except:
		print('Error in Command Line Input!\nPlease Enter Format: python <DatafileName> <Fraction>')
		return
	start_time = time.time()
	data = []
	if isCSV:
		uniqueItems = fetchCSVdata(data,fileName)
	else:
		uniqueItems = fetchtxtData(data,fileName)

	global MIN_SUPPORT_COUNT
	MIN_SUPPORT_COUNT = math.ceil(NO_OF_TRANSACTION * FRACTION)
	FPTree(data,uniqueItems)
	end_time = time.time()
	global EXECUTION_TIME
	EXECUTION_TIME = end_time - start_time
	process = psutil.Process(os.getpid())
	global MEMORY
	MEMORY = process.memory_info().rss
	printData()

if __name__ == "__main__":
    main()

